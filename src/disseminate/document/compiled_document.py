"""
A compiled document class for documents that need to be compiled to their
final version.
"""
from tempfile import mkdtemp
from shutil import rmtree
import os.path
import subprocess

from ..utils import mkdir_p
from .document import Document, DocumentError
from .. import settings


class CompiledDocumentError(DocumentError):
    """An error in generating a compiled document"""

    exit_code = None
    shell_out = None


class CompiledDocument(Document):
    """A compiled document is a document that requires additional
    compilation steps to generate the final target."""

    document = None
    compiled_targets = None
    uncompiled_targets = None

    _temp_dir = None

    def __init__(self, targets, *args, **kwargs):

        # Setup the compilation
        # First separate the compiled and uncompiled targets
        self.compiled_targets = {k: v for k,v in targets.items()
                                 if k in settings.compiled_exts}
        self.uncompiled_targets = {k: v for k,v in targets.items()
                                   if k not in settings.compiled_exts}

        # For the compiled targets, setup a temporary directory
        self._temp_dir = mkdtemp()

        # Modify the uncompiled targets to list the intermediary files to
        # compile, if they're not available.
        for target, target_filepath in self.compiled_targets.items():
            # Determine the intermediary target. ex: '.tex' for '.pdf'
            intermediary_target = settings.compiled_exts[target][0]

            # In this case, the intermediary file is already being created,
            # so a temporary one doesn't have to make
            if intermediary_target in self.uncompiled_targets:
                continue

            # Otherwise the intermediary target should be added to the
            # uncompiled_targets with a temporary target_filepath
            target_filename = os.path.split(target_filepath)[1]
            target_filepath = os.path.join(self._temp_dir, target_filename)
            self.uncompiled_targets[intermediary_target] = target_filepath

        # create the document as usual with the uncompiled targets
        kwargs['targets'] = self.uncompiled_targets
        self.document = Document(*args, **kwargs)

    def __del__(self):
        """Clean up any temp directories no longer in use."""
        if self._temp_dir is not None:
            rmtree(self._temp_dir, ignore_errors=True)

    def render(self, *args, **kwargs):
        """Render the documents and compile the required documents."""
        # Render the documents, as usual
        self.document.render(*args, **kwargs)

        # Find the targets that should be turned into compile targets
        # TODO: This step could use some caching and/or checking of mtimes
        for target, target_filepath in self.compiled_targets.items():
            # Check to see if the target directory needs to be created
            if settings.create_dirs:
                mkdir_p(target_filepath)

            # Determine the intermediary target. ex: '.tex'
            intermediary_target, compile_cmd = settings.compiled_exts[target]

            # Get the location of the intermediate target file and proceed if
            # it's valid
            if (intermediary_target in self.document.targets and
               os.path.isfile(self.document.targets[intermediary_target])):
                # Get the src_file path, which is the target_filepath of the
                # intermediary file
                src_filepath = self.document.targets[intermediary_target]

                # Determine the compiled_intermediary_target (.pdf). This is
                # the file that is generated by compiling the
                # src_filepath (.tex) in the temp directory
                p = (os.path.splitext(src_filepath)[0] + target)
                compiled_intermediary_target_filepath = p


                # Setup and execute the command
                cmd_kwargs = {'in_file':
                                src_filepath,
                              'out_dir':
                                self._temp_dir}
                cmd = compile_cmd.format(**cmd_kwargs)

                # execute the command
                p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                                     stderr=subprocess.PIPE)
                shell_out, shell_err = p.communicate()

                # try:
                #     result = subprocess.check_output(cmd, shell=True,
                #                             stderr=subprocess.STDOUT)
                # except subprocess.CalledProcessError as e:
                #     exit_code = e.returncode

                # Raise an error if the compiled_intermediary_target was not
                # generated or the program exited with a non-successful error
                # code
                if (not os.path.isfile(compiled_intermediary_target_filepath) or
                   p.returncode != 0):

                    msg = "Could not compile file '{}'".format(target_filepath)
                    e = CompiledDocumentError(msg)
                    e.exit_code = p.returncode
                    e.shell_out = shell_out.decode("utf-8")
                    raise e

                # At this stage, the file was succesfully created. Now link it
                # to the correct target_filepath. Overwrite if necessary
                try:
                    os.link(compiled_intermediary_target_filepath,
                            target_filepath)
                except FileExistsError:
                    os.remove(target_filepath)
                    os.link(compiled_intermediary_target_filepath,
                            target_filepath)
